# Компонент Sprite Merger

## Обзор

Класс `SpriteMerger` обрабатывает объединение спрайт-ресурсов из нескольких стилей Mapbox в единые наборы спрайтов. Он обрабатывает как обычные, так и высококачественные (@2x) изображения спрайтов и их соответствующие JSON метаданные, создавая объединенные спрайт-ресурсы, которые могут использоваться смешанными стилями.

## Основной функционал

### Процесс объединения спрайтов

Процесс объединения спрайтов включает несколько ключевых этапов:

1. **Сбор спрайтов**: Сканирует и собирает файлы спрайтов из нескольких исходных стилей
2. **Дедупликация спрайтов**: Удаляет дублирующиеся спрайты на основе сравнения PNG файлов и JSON метаданных
3. **Объединение изображений**: Объединяет PNG изображения спрайтов с помощью команды ImageMagick montage
4. **Объединение метаданных**: Объединяет JSON метаданные спрайтов с корректировкой координат
5. **Генерация выходных данных**: Создает единые наборы спрайтов для обычных и @2x версий

### Дедупликация спрайтов

Компонент автоматически обнаруживает и удаляет дублирующиеся спрайты, что позволяет избежать избыточности в финальных стилях:

```ruby
def deduplicate_sprites(sprite_files)
  return [] if sprite_files.empty?
  return sprite_files if sprite_files.length == 1
  
  # Группируем спрайты по хешу
  sprite_groups = group_sprites_by_hash(sprite_files)
  
  # Логируем информацию о дубликатах
  if sprite_groups.length < sprite_files.length
    sprite_groups.each_with_index do |group, index|
      if group.length > 1
        sprite_names = group.map { |s| File.basename(s[:dir]) }
        LOGGER.info "Found duplicate sprites in group #{index + 1}: #{sprite_names.join(', ')}"
      end
    end
  end
  
  # Выбираем по одному спрайту из каждой группы
  sprite_groups.map { |group| group.first }
end
```

**Процесс дедупликации**:
- **Вычисление хеша**: Для каждого спрайта вычисляется MD5 хеш на основе PNG файла и JSON метаданных
- **Группировка**: Спрайты группируются по хешу для выявления дубликатов
- **Логирование**: Информация о найденных дубликатах записывается в лог
- **Выбор представителя**: Из каждой группы дубликатов выбирается один спрайт

**Вычисление хеша спрайта**:
```ruby
def compute_sprite_hash(sprite)
  png_hash = Digest::MD5.file(sprite[:png_file]).hexdigest
  json_hash = Digest::MD5.hexdigest(sprite[:json_data].to_json)
  
  "#{png_hash}_#{json_hash}"
end
```

**Проверка идентичности спрайтов**:
```ruby
def sprites_identical?(sprite1, sprite2)
  return false unless sprite1 && sprite2
  
  # Сравниваем PNG файлы
  png_identical = FileUtils.compare_file(sprite1[:png_file], sprite2[:png_file])
  return false unless png_identical
  
  # Сравниваем JSON метаданные
  json_identical = sprite1[:json_data] == sprite2[:json_data]
  
  png_identical && json_identical
end
```

**Преимущества дедупликации**:
- **Уменьшение размера**: Исключение дублирующихся спрайтов снижает размер финальных файлов
- **Улучшение производительности**: Меньше спрайтов для обработки и загрузки
- **Оптимизация памяти**: Снижение потребления памяти при рендеринге карт
- **Упрощение отладки**: Более чистые логи и отчеты о процессе объединения

### Ключевые методы

#### `merge_all_sprites`
Обрабатывает все настроенные наборы спрайтов в системе, перебирая конфигурацию и вызывая отдельные операции объединения.

#### `merge_sprites_for_mix(mix_id)`
Объединяет спрайты для конкретного смешанного стиля:
- Собирает обычные и @2x спрайты из всех исходных стилей
- Выполняет дедупликацию спрайтов для удаления дубликатов
- Объединяет каждый набор спрайтов независимо
- Возвращает статус успеха для мониторинга

#### `merge_sprite_set(sprite_files, mix_id, high_dpi)`
Объединяет набор спрайтов (обычные или @2x):
- Проверяет существование и доступность файлов спрайтов
- Выполняет объединение изображений с помощью ImageMagick
- Обновляет координаты метаданных для правильного позиционирования

### Сбор спрайтов

Компонент собирает файлы спрайтов из нескольких источников, сканируя директорию спрайтов:

```ruby
def collect_sprite_files(mix_id, high_dpi = false)
  if high_dpi
    pattern = "#{@sprites_dir}/#{mix_id}_*_@2x"
    sprite_dirs = Dir.glob(pattern).select { |d| Dir.exist?(d) }
  else
    pattern = "#{@sprites_dir}/#{mix_id}_*"
    sprite_dirs = Dir.glob(pattern).select { |d| Dir.exist?(d) && !d.end_with?('_@2x') }
  end
  
  sprite_dirs.map { |dir| load_sprite_data(dir) }.compact
end
```

**Детали процесса**:
- Использует glob-паттерны для поиска директорий спрайтов для конкретного смешивания
- Фильтрует директории @2x при обработке высококачественных спрайтов
- Загружает данные спрайтов (PNG и JSON) из каждой директории
- Возвращает уплотненный массив валидных данных спрайтов

### Объединение изображений

Использует ImageMagick для объединения изображений спрайтов с вертикальным наложением:

```ruby
def merge_png_files(png_files, output_png)
  return false if png_files.empty?
  
  if png_files.length == 1
    FileUtils.cp(png_files.first, output_png)
    return true
  end
  
  # Используем ImageMagick montage для объединения
  cmd = "montage #{png_files.join(' ')} -tile 1x -geometry +0+0 #{output_png}"
  system(cmd)
end
```

**Стратегия объединения**:
- **Один спрайт**: Прямое копирование файла для эффективности
- **Несколько спрайтов**: Вертикальное наложение с помощью ImageMagick montage
- **Макет плиток**: Сетка 1xN для вертикального расположения
- **Геометрия**: +0+0 интервал между спрайтами

### Объединение метаданных

Объединяет JSON метаданные спрайтов с корректировкой координат для правильного позиционирования иконок:

```ruby
def merge_json_metadata(sprite_files, png_files)
  merged_json = {}
  current_y = 0
  
  sprite_files.each_with_index do |sprite_file, index|
    sprite_file[:json_data].each do |icon_name, icon_data|
      # Корректируем Y координаты для вертикального наложения
      adjusted_data = icon_data.dup
      adjusted_data['y'] = icon_data['y'] + current_y
      merged_json[icon_name] = adjusted_data
    end
    
    # Обновляем Y смещение для следующего спрайта
    current_y += get_sprite_height(png_files[index])
  end
  
  merged_json
end
```

**Процесс корректировки координат**:
- **Расчет Y-смещения**: Накопление высоты предыдущих спрайтов
- **Позиционирование иконок**: Корректировка Y координаты каждой иконки на величину смещения
- **Сохранение метаданных**: Сохранение исходных X координат и размеров
- **Именование иконок**: Сохранение исходных имен иконок для избежания конфликтов

### Структура выходных данных

Генерирует единые наборы спрайтов в директории sprite:

```
sprite/
  mix_style1_sprite.png      # Объединенные обычные спрайты
  mix_style1_sprite.json     # Объединенные метаданные для обычных спрайтов
  mix_style1_sprite@2x.png   # Объединенные @2x спрайты (высококачественные)
  mix_style1_sprite@2x.json  # Объединенные метаданные для @2x спрайтов
```

**Организация файлов**:
- **Соглашение об именовании**: Использует mix_id с суффиксом `_sprite`
- **Поддержка разрешений**: Отдельные файлы для обычных и @2x версий
- **Выравнивание метаданных**: JSON файлы соответствуют PNG файлам
- **Структура директорий**: Все объединенные спрайты в одной директории sprite/

### Поддержка высокого разрешения

Обрабатывает как обычные, так и @2x версии спрайтов с независимой обработкой и автоматическим резервным созданием:

**Обычные спрайты**:
- Стандартное разрешение (1x) изображения спрайтов
- Базовая система координат
- Стандартные размеры иконок

**@2x спрайты**:
- Высококачественное разрешение (2x) изображения спрайтов
- Масштабированная система координат
- Удвоенные размеры иконок для дисплеев retina

**Различия в обработке**:
- Отдельные паттерны сбора для каждого разрешения
- Независимые процессы объединения
- Соображения масштабирования координат для @2x спрайтов
- Различные соглашения об именовании выходных файлов

**Резервное создание**:
Когда @2x спрайты отсутствуют или неполны для исходных стилей, система автоматически создает их из обычных спрайтов:
- Использует ImageMagick для масштабирования обычных изображений спрайтов в 2 раза
- Масштабирует координаты и размеры в JSON метаданных пропорционально
- Создает масштабированные спрайты непосредственно в существующих @2x директориях
- Поддерживает визуальную согласованность на различных плотностях дисплеев

### Обработка одного спрайта

Оптимизирует производительность для сценариев с только одним исходным спрайтом:

**Стратегия оптимизации**:
- **Прямое копирование**: Использует FileUtils.cp вместо ImageMagick
- **Сохранение метаданных**: Не требуется корректировка координат
- **Прирост производительности**: Избегает ненужной обработки изображений
- **Эффективность ресурсов**: Минимальное использование памяти и CPU

### Обработка ошибок

Комплексная обработка ошибок для различных сценариев сбоев:

**Ошибки файловой системы**:
- Валидация отсутствующих файлов спрайтов
- Проверка прав доступа к директориям
- Проверка доступности дискового пространства

**Ошибки обработки изображений**:
- Обработка сбоев команд ImageMagick
- Обнаружение неверного формата PNG файлов
- Восстановление поврежденных файлов изображений

**Ошибки метаданных**:
- Восстановление ошибок парсинга JSON
- Обработка неверной структуры метаданных
- Валидация отсутствующих обязательных полей

**Graceful Degradation**:
- Продолжение обработки при сбоях отдельных спрайтов
- Логирование ошибок для отладки
- Возврат частичных результатов когда возможно

### Интеграция

Бесшовно интегрируется с другими компонентами системы:

**Интеграция с StyleDownloader**:
- Работает с загруженными источниками спрайтов
- Обрабатывает спрайты из нескольких источников стилей
- Обрабатывает файлы спрайтов, организованные StyleDownloader

**Интеграция с StyleMixer**:
- Предоставляет объединенные спрайт-ресурсы для смешивания стилей
- Обновляет ссылки на спрайты в смешанных стилях
- Обеспечивает доступность спрайтов для финальных стилей

**Интеграция с конфигурацией**:
- Использует конфигурацию из `styles_config.yaml`
- Обрабатывает спрайты на основе определений смешивания стилей
- Поддерживает пользовательские идентификаторы смешивания

### Соображения производительности

Оптимизировано для эффективной обработки спрайтов:

**Управление памятью**:
- Потоковая обработка больших файлов спрайтов вместо полной загрузки в память
- Последовательная обработка спрайтов для минимизации использования памяти
- Очистка временных файлов после обработки

**Оптимизация обработки**:
- Эффективное копирование файлов для одиночных спрайтов
- Оптимизация ImageMagick для больших наборов спрайтов
- Поддержка параллельной обработки для нескольких смешиваний

**Эффективность ресурсов**:
- Минимальные операции ввода-вывода на диск
- Оптимизированное сжатие изображений
- Эффективные алгоритмы обработки метаданных
