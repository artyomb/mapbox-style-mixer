ruby:
  style_name = params[:style]
  style_url = style_name ? "#{request.base_url}/styles/#{style_name}" : nil

#loading-indicator
  .loading-progress
    .loading-text Loading map...
    .progress-bar
      .progress-fill

- if style_name
  .layer-controls
    .mode-switcher
      button.mode-button.active id="mode-filters" onclick="switchMode(this, 'filters')" Filters
      button.mode-button id="mode-layers" onclick="switchMode(this, 'layers')" Layers
    button.control-button onclick="toggleBasemap()" Toggle Basemap
    button.control-button onclick="toggleHoverMode()" id="hover-mode-btn" Hover Mode
    
    #filters-panel.control-panel.active
      button.control-button onclick="toggleAllFilters()" Toggle All Filters
      #filter-buttons
    
    #layers-panel.control-panel
      button.control-button onclick="toggleAllLayers()" Toggle All Layers
      #layer-buttons

#map-container
  #map_base.map-layer
  #map.map-layer data-style-url="#{style_url}"
  
  #performance-panel.performance-overlay
    button.performance-toggle onclick="togglePerformancePanel()" Ã—
    .performance-content
      .metric-row
        .metric
          span.metric-label FPS:
          span.metric-value#fps-value 0
        .metric
          span.metric-label Frame:
          span.metric-value#frame-time-value 0ms
        .metric
          span.metric-label Memory:
          span.metric-value#memory-usage-value 0MB
        .metric
          span.metric-label Zoom:
          span.metric-value#zoom-level-value 0
      .metric-row
        .metric
          span.metric-label Tiles:
          span.metric-value#tiles-loaded-value 0
        .metric
          span.metric-label Loading:
          span.metric-value#tiles-loading-value 0
        .metric
          span.metric-label Layers:
          span.metric-value#layers-active-value 0

javascript:
  const mapEl = document.getElementById('map');
  const style_url = (mapEl && mapEl.dataset) ? (mapEl.dataset.styleUrl || null) : null;
  let showBasemap = true, currentMode = 'filters';
  let hoverMode = 'click';
  let layerStates = {}, filterStates = {};
  let map = null, map_base = null;
  let styleLoaded = false, resourcesLoaded = 0, totalResources = 0;
  let tilesLoaded = 0, tilesTotal = 0;
  let currentStyle = null;
  const subFilterStatesBeforeGroupToggle = {};
  const layerIdToDomId = {};

  function toDomId(prefix, id) {
    return `${prefix}-${String(id).replace(/[^a-zA-Z0-9_-]/g, '_')}`;
  }
  
  function getLocalizedFilterName(locale, filterId) {
    if (!locale) return filterId;
    const languagePriority = ['en-US', 'en', 'ru'];
    
    for (const lang of languagePriority) {
      if (locale[lang]?.[filterId]) return locale[lang][filterId];
    }
    
    for (const lang in locale) {
      if (locale[lang]?.[filterId]) return locale[lang][filterId];
    }
    
    return filterId;
  }
  
  const showLoading = () => document.getElementById('loading-indicator').style.display = 'block';
  const hideLoading = () => document.getElementById('loading-indicator').style.display = 'none';
  
  const updateLoadingProgress = () => {
    let progress = 0;
    let loadingText = 'Loading map...';
    
    if (totalResources > 0) {
      const resourceProgress = Math.round((resourcesLoaded / totalResources) * 50);
      progress = resourceProgress;
      loadingText = `Loading resources... ${resourceProgress * 2}%`;
    }
    
    if (map?.getStyle()?.sources) {
      const sources = Object.keys(map.getStyle().sources);
      if (sources.length > 0) {
        const tileProgress = Math.round((tilesLoaded || 0) / sources.length * 50);
        progress = Math.min(100, (totalResources > 0 ? 50 : 0) + tileProgress);
        loadingText = `Loading tiles... ${progress}%`;
      }
    }
    
    document.querySelector('.loading-text').textContent = loadingText;
    document.querySelector('.progress-fill').style.width = `${progress}%`;
  };
  
  function switchMode(arg1, arg2) {
    const isStringArg = typeof arg1 === 'string';
    const mode = isStringArg ? arg1 : arg2;
    const target = isStringArg ? null : (arg1?.currentTarget || arg1);
    currentMode = mode;
    document.querySelectorAll('.mode-button').forEach(btn => btn.classList.remove('active'));
    if (target) target.classList.add('active');
    else document.getElementById(`mode-${mode}`)?.classList.add('active');
    
    document.getElementById('filters-panel').classList.toggle('active', mode === 'filters');
    document.getElementById('layers-panel').classList.toggle('active', mode === 'layers');
    
    mode === 'filters' ? applyFilterMode() : applyLayerMode();
  }
  
  function applyFilterMode() {
    if (currentStyle?.layers) {
      currentStyle.layers.forEach(layer => {
        if (map.getLayer(layer.id)) {
          map.setLayoutProperty(layer.id, 'visibility', 'visible');
          map.setFilter(layer.id, null); // TEST SECOND LEVEL FILTERS
        }
      });
    }
    
    if (currentStyle?.metadata?.filters) {
      Object.keys(currentStyle.metadata.filters).forEach(filterId => {
        const isActive = filterStates[filterId] || false;
        applyFilter(filterId, isActive);
      });
    }
  }
  
  function applyLayerMode() {
    Object.keys(filterStates).forEach(filterId => filterStates[filterId] = true);
    updateFilterButtons();
    Object.keys(layerStates).forEach(layerId => {
      const visibility = layerStates[layerId] ? 'visible' : 'none';
      if (map.getLayer(layerId)) map.setLayoutProperty(layerId, 'visibility', visibility);
    });
  }
  
  const checkStyleResources = (style) => {
    totalResources = 0; resourcesLoaded = 0;
    const promises = [];
    
    if (style.sprite) {
      totalResources += 2;
      promises.push(
        Promise.all([
          fetch(style.sprite + '.json').catch(() => {}),
          fetch(style.sprite + '.png').catch(() => {})
        ]).then(() => { resourcesLoaded += 2; updateLoadingProgress(); })
      );
    }
    
    if (style.glyphs) {
      totalResources += 1;
      promises.push(Promise.resolve().then(() => { resourcesLoaded++; updateLoadingProgress(); }));
    }
    
    if (totalResources > 0) {
      showLoading();
      updateLoadingProgress();
      Promise.all(promises).then(() => { styleLoaded = true; });
    }
  };
  
  function initializeMap() {
    showLoading();
    
    map_base = new maplibregl.Map({
      container: 'map_base', style: 'https://demotiles.maplibre.org/style.json',
      center: [35.15, 47.41], zoom: 2, attributionControl: false,
      interactive: false, trackResize: false, validateStyle: false
    });
    map_base.once('idle', () => { try { map_base.setProjection({ type: 'globe' }); } catch (_) {} });

    map = new maplibregl.Map({
      container: 'map', style: style_url || 'https://demotiles.maplibre.org/style.json',
      center: [35.15, 47.41], zoom: 2, attributionControl: false, validateStyle: false
    });

    map.addControl(new maplibregl.NavigationControl());
    map.on('error', (e) => { console.error('[MapLibre ERROR]', e?.error || e); });

    if (style_url) {
      function syncMaps(map, map_base) {
        map.on('move', () => {
          const center = map.getCenter(), zoom = map.getZoom();
          const bearing = map.getBearing(), pitch = map.getPitch();
          map_base.jumpTo({center, zoom, bearing, pitch});
          map_base.triggerRepaint(); map_base.resize();
        });
      }
      syncMaps(map, map_base);
      map.on('projectiontransition', (e) => {
        const applyProjection = () => {
          try { map_base.setProjection({ type: e.newProjection }); } catch (_) {}
          map_base.triggerRepaint(); map_base.resize();
        };
        if (map_base.isStyleLoaded && map_base.isStyleLoaded()) applyProjection();
        else map_base.once('idle', applyProjection);
      });
    }

    map.on('load', async () => {
      const onStyleReady = () => {
        try { map.setProjection({ type: 'globe' }); } catch (_) {}
        try { map.addControl(new maplibregl.GlobeControl(), 'top-right'); } catch (_) {}
        if (currentStyle) {
          createLayerButtons();
          createFilterButtons();
          applyFilterMode();
        }
      };

      try { currentStyle = map.getStyle(); if (currentStyle) { checkStyleResources(currentStyle); } } catch (_) {}
      map.once('idle', onStyleReady);
      
      const popup = new maplibregl.Popup({closeButton: false, closeOnClick: false});

      map.on('click', function (e) {
        const features = this.queryRenderedFeatures(e.point);
        if (features.length > 0) {
          hoverMode === 'click' && popupFeature(features, e);
          console.log('Clicked feature:', features[0]);
        }
      });

      function popupFeature(features, e) {
        let tt = (tooltip, feat) => tooltip?.replace(/\{([^}]+)\}/g, (match, prop) => {
            let value = feat;
            for (const p of prop.split('.')) { value = value?.[p]; }
            return typeof value === 'object' ? JSON.stringify(value, null, 2) : (value || '');
        });

        let tooltips = features.map((feat) => {
          return tt(feat.layer.metadata?.tooltip, feat) ||
          tt(`<pre>"id": {id},\n"source": {source},\n"source-layer": {sourceLayer},\n"properties": {properties}</pre>`, feat);
        });
        popup.setLngLat(e.lngLat).setHTML(tooltips.join('<br>')).addTo(map);
      }

      let timeout, point;
      map.on('mousemove', (e) => {
        if (hoverMode !== 'hover') {
          map.getCanvas().style.cursor = '';
          popup.remove();
          return;
        }
        
        clearTimeout(timeout);
        const features = map.queryRenderedFeatures(e.point);
        const hasFeatures = features.length > 0;
        
        map.getCanvas().style.cursor = hasFeatures ? 'crosshair' : '';
        if (hasFeatures) {
          timeout = setTimeout(() => popupFeature(features, e), 100);
        } else {
          popup.remove();
        }
        
        if (point && !point.equals(e.point)) popup.remove();
        point = e.point.clone();
      });
      
      map.on('sourcedata', (e) => {
        if (e.sourceId && e.isSourceLoaded) {
          tilesLoaded++;
          if (tilesTotal === 0) tilesTotal = Object.keys(map.getStyle().sources).length;
          updateLoadingProgress();
        }
      });
      
      map.on('idle', () => {
        const allResourcesLoaded = totalResources === 0 || styleLoaded;
        const allTilesLoaded = tilesTotal === 0 || tilesLoaded >= tilesTotal;
        
        if (allResourcesLoaded && allTilesLoaded) {
          hideLoading();
        }
      });
      
      setTimeout(() => hideLoading(), 10000);
      
      startPerformanceMonitoring();
      requestAnimationFrame(countFrame);
      updateHoverModeButton();
    });
  }

  function toggleBasemap() {
    showBasemap = !showBasemap;
    document.getElementById('map_base').style.display = showBasemap ? 'block' : 'none';
  }

  function toggleHoverMode() {
    hoverMode = hoverMode === 'hover' ? 'click' : 'hover';
    updateHoverModeButton();
  }

  function updateHoverModeButton() {
    const btn = document.getElementById('hover-mode-btn');
    if (!btn) return;
    
    const isHoverMode = hoverMode === 'hover';
    btn.textContent = isHoverMode ? 'Click Mode' : 'Hover Mode';
    btn.className = `control-button ${isHoverMode ? 'active' : ''}`;
  }

  function toggleAllLayers() {
    if (currentMode !== 'layers') return;
    const allVisible = Object.values(layerStates).every(state => state);
    const newState = !allVisible;
    
    Object.keys(layerStates).forEach(layerId => {
      layerStates[layerId] = newState;
      const visibility = newState ? 'visible' : 'none';
      if (map.getLayer(layerId)) map.setLayoutProperty(layerId, 'visibility', visibility);
    });
    
    updateLayerButtons();
  }

  function toggleLayer(layerId) {
    if (currentMode !== 'layers') return;
    layerStates[layerId] = !layerStates[layerId];
    const visibility = layerStates[layerId] ? 'visible' : 'none';
    
    if (map.getLayer(layerId)) map.setLayoutProperty(layerId, 'visibility', visibility);
    updateLayerButtons();
  }

  function updateLayerButtons() {
    Object.keys(layerStates).forEach(layerId => {
      const btnId = layerIdToDomId[layerId] || toDomId('layer', layerId);
      const button = document.getElementById(btnId);
      if (button) button.className = `control-button ${layerStates[layerId] ? 'active' : 'inactive'}`;
    });
  }

  function toggleAllFilters() {
    if (currentMode !== 'filters') return;
    if (!currentStyle?.metadata?.filters) return;
    
    const allActive = Object.values(filterStates).every(state => state);
    const newState = !allActive;
    
    Object.keys(subFilterStatesBeforeGroupToggle).forEach(k => delete subFilterStatesBeforeGroupToggle[k]);
    Object.keys(currentStyle.metadata.filters).forEach(filterId => {
      const filterConfig = currentStyle.metadata.filters[filterId];
      
      if (filterConfig && filterConfig.length > 1) {
        filterConfig.forEach(item => {
          const subFilterKey = `${filterId}_${item.id}`;
          filterStates[subFilterKey] = newState;
        });
      }

      filterStates[filterId] = newState;
      applyFilter(filterId, newState);
    });
    
    updateFilterButtons();
  }

  function toggleFilterGroup(filterId) {
    if (currentMode !== 'filters') return;
    
    const filterConfig = currentStyle.metadata.filters[filterId];
    const isCurrentlyActive = filterStates[filterId];
    
    if (isCurrentlyActive) {
      if (filterConfig && filterConfig.length > 1) {
        subFilterStatesBeforeGroupToggle[filterId] = {};
        filterConfig.forEach(item => {
          const subFilterKey = `${filterId}_${item.id}`;
          subFilterStatesBeforeGroupToggle[filterId][item.id] = filterStates[subFilterKey];
          filterStates[subFilterKey] = false;
        });
      }
      filterStates[filterId] = false;
      applyFilter(filterId, false);
    } else {
      if (filterConfig && filterConfig.length > 1) {
        const saved = subFilterStatesBeforeGroupToggle[filterId];
        const anyUserSelectionWhileOff = filterConfig.some(item => filterStates[`${filterId}_${item.id}`]);
        if (!anyUserSelectionWhileOff) {
          filterConfig.forEach(item => {
            const subFilterKey = `${filterId}_${item.id}`;
            if (saved && saved[item.id] !== undefined) {
              filterStates[subFilterKey] = saved[item.id];
            } else {
              filterStates[subFilterKey] = true;
            }
          });
        }
        delete subFilterStatesBeforeGroupToggle[filterId];
      }
      filterStates[filterId] = true;
      applyFilter(filterId, true);
    }
    
    updateFilterButtons();
  }

  function toggleSubFilter(groupId, subFilterId) {
    if (currentMode !== 'filters') return;
    const subFilterKey = `${groupId}_${subFilterId}`;
    filterStates[subFilterKey] = !filterStates[subFilterKey];
    
    const filterConfig = currentStyle.metadata.filters[groupId];
    if (filterConfig && filterConfig.length > 1) {
      const activeSubFilters = filterConfig.filter(item => {
        const key = `${groupId}_${item.id}`;
        return filterStates[key];
      });
      filterStates[groupId] = activeSubFilters.length > 0;
    }
    
    applyFilter(groupId, !!filterStates[groupId]);
    updateFilterButtons();
  }

  function toggleFilter(filterId) {
    if (currentMode !== 'filters') return;
    filterStates[filterId] = !filterStates[filterId];
    applyFilter(filterId, filterStates[filterId]);
    updateFilterButtons();
  }

  function applyFilter(filterId, isActive) {
    if (currentMode !== 'filters') return;
    if (!currentStyle?.metadata?.filters) return;
    
    const filterConfig = currentStyle.metadata.filters[filterId];
    if (!filterConfig) return;
    
// ====== TEST SECOND LEVEL FILTERS ====== //

    const hasMapboxFilters = filterConfig.some(filter => filter.filter);
    
    if (hasMapboxFilters) {
      applyLevel2Filter(filterId, isActive, filterConfig);
    } else {
      applyLevel1Filter(filterId, isActive, filterConfig);
    }
  }

// ====== END TEST SECOND LEVEL FILTERS ====== //

  function applyLevel1Filter(filterId, isActive, filterConfig) {
    currentStyle.layers.forEach(layer => {
      if (layer.metadata?.filter_id) {
        const matchingFilter = filterConfig.find(filter => filter.id === layer.metadata.filter_id);
        if (matchingFilter) {
          if (filterConfig.length > 1) {
            const subFilterKey = `${filterId}_${layer.metadata.filter_id}`;
            const subFilterActive = filterStates[subFilterKey];
            const visibility = (isActive && subFilterActive) ? 'visible' : 'none';
            if (map.getLayer(layer.id)) {
              map.setLayoutProperty(layer.id, 'visibility', visibility);
            }
          } else {
            if (map.getLayer(layer.id)) {
              const visibility = isActive ? 'visible' : 'none';
              map.setLayoutProperty(layer.id, 'visibility', visibility);
            }
          }
        }
      }
    });
  }

// ====== TEST SECOND LEVEL FILTERS ====== //

  function applyLevel2Filter(filterId, isActive, filterConfig) {
    const subFiltersWithExpr = filterConfig.filter(f => !!f.filter);
    const subFiltersWithoutExpr = filterConfig.filter(f => !f.filter);

    const generalLayers = currentStyle.layers.filter(layer => layer.metadata?.filter_id === filterId);

    const childLayersBySubId = {};
    filterConfig.forEach(f => {
      childLayersBySubId[f.id] = currentStyle.layers
        .filter(layer => layer.metadata?.filter_id === f.id)
        .map(l => l.id);
    });

    const hasGeneralLayers = generalLayers.length > 0 && subFiltersWithExpr.length > 0;
    const hasChildLayers = Object.values(childLayersBySubId).some(arr => (arr && arr.length > 0));

    if (!isActive) {
      if (hasGeneralLayers) {
        generalLayers.forEach(layer => {
          if (map.getLayer(layer.id)) {
            map.setLayoutProperty(layer.id, 'visibility', 'none');
            map.setFilter(layer.id, null);
          }
        });
      }
      if (hasChildLayers) {
        Object.values(childLayersBySubId).forEach(ids => {
          ids.forEach(id => {
            if (map.getLayer(id)) map.setLayoutProperty(id, 'visibility', 'none');
          });
        });
      }
      return;
    }

    if (hasGeneralLayers) {
      const activeWithExpr = subFiltersWithExpr.filter(f => {
        const key = `${filterId}_${f.id}`;
        return filterStates[key] !== false;
      });

      if (activeWithExpr.length === 0) {
        generalLayers.forEach(layer => {
          if (map.getLayer(layer.id)) {
            map.setLayoutProperty(layer.id, 'visibility', 'none');
            map.setFilter(layer.id, null);
          }
        });
      } else if (activeWithExpr.length === 1) {
        const expr = activeWithExpr[0].filter;
        generalLayers.forEach(layer => {
          if (map.getLayer(layer.id)) {
            map.setLayoutProperty(layer.id, 'visibility', 'visible');
            map.setFilter(layer.id, expr);
          }
        });
      } else {
        const exprs = activeWithExpr.map(f => f.filter);
        const combined = ['any', ...exprs];
        generalLayers.forEach(layer => {
          if (map.getLayer(layer.id)) {
            map.setLayoutProperty(layer.id, 'visibility', 'visible');
            map.setFilter(layer.id, combined);
          }
        });
      }
    }

    if (hasChildLayers) {
      filterConfig.forEach(sf => {
        const ids = childLayersBySubId[sf.id] || [];
        if (!ids.length) return;
        const subKey = `${filterId}_${sf.id}`;
        const on = (filterStates[subKey] !== false) && isActive;
        ids.forEach(id => {
          if (map.getLayer(id)) map.setLayoutProperty(id, 'visibility', on ? 'visible' : 'none');
        });
      });
    }
  }

// ====== END TEST SECOND LEVEL FILTERS ====== //

  function applySubFilter(groupId, subFilterId, isActive) {
    if (currentMode !== 'filters') return;
    if (!currentStyle?.metadata?.filters) return;
    
    const filterConfig = currentStyle.metadata.filters[groupId];
    if (!filterConfig) return;
    
    const subFilter = filterConfig.find(filter => filter.id === subFilterId);
    if (!subFilter) return;

// ====== TEST SECOND LEVEL FILTERS ====== //

    const hasMapboxFilters = filterConfig.some(filter => filter.filter);
    
    if (hasMapboxFilters) {
      applyLevel2Filter(groupId, filterStates[groupId], filterConfig);
    } else {
      const groupActive = filterStates[groupId];
      
      currentStyle.layers.forEach(layer => {
        if (layer.metadata?.filter_id && layer.metadata.filter_id === subFilterId) {
          if (map.getLayer(layer.id)) {
            const visibility = (groupActive && isActive) ? 'visible' : 'none';
            map.setLayoutProperty(layer.id, 'visibility', visibility);
          }
        }
      });
    }

// ====== END TEST SECOND LEVEL FILTERS ====== //

  }

  function updateFilterButtons() {
    Object.keys(filterStates).forEach(filterId => {
      const groupButton = document.getElementById(`filter-${filterId}`);
      if (groupButton) {
        groupButton.className = `control-button ${filterStates[filterId] ? 'active' : 'inactive'} filter-group-button`;
      }
      
      const subButton = document.getElementById(`filter-sub-${filterId}`);
      if (subButton) {
        const subButtons = subButton.querySelectorAll('.filter-sub-button');
        subButtons.forEach(btn => {
          const subFilterId = btn.id.replace(`filter-sub-${filterId}-`, '');
          const subFilterKey = `${filterId}_${subFilterId}`;
          btn.className = `control-button ${filterStates[subFilterKey] ? 'active' : 'inactive'} filter-sub-button`;
        });
      }
    });
  }

  function createLayerButtons() {
    if (!currentStyle) return;
    
    const layerButtonsContainer = document.getElementById('layer-buttons');
    
    if (currentStyle.layers) {
      currentStyle.layers.forEach(layer => {
        const button = document.createElement('button');
        const buttonId = toDomId('layer', layer.id);
        button.id = buttonId;
        button.className = 'control-button active';
        button.textContent = layer.id;
        button.onclick = () => toggleLayer(layer.id);
        layerButtonsContainer.appendChild(button);
        layerStates[layer.id] = true;
        layerIdToDomId[layer.id] = buttonId;
      });
    }
  }

  function createFilterButtons() {
    if (!currentStyle) return;
    
    const filterButtonsContainer = document.getElementById('filter-buttons');
    
    if (currentStyle.metadata?.filters) {
      Object.keys(currentStyle.metadata.filters).forEach(filterId => {
        const filterConfig = currentStyle.metadata.filters[filterId];
        const locale = getLocalizedFilterName(currentStyle.metadata.locale, filterId);
        
        const groupContainer = document.createElement('div');
        groupContainer.className = 'filter-group';
        groupContainer.id = `filter-group-${filterId}`;
        
        const groupButton = document.createElement('button');
        groupButton.id = `filter-${filterId}`;
        groupButton.className = 'control-button active filter-group-button';
        groupButton.textContent = locale;
        groupButton.onclick = () => toggleFilterGroup(filterId);
        groupContainer.appendChild(groupButton);
        
        if (filterConfig.length > 1) {
          const subButtonsContainer = document.createElement('div');
          subButtonsContainer.className = 'filter-sub-buttons';
          subButtonsContainer.id = `filter-sub-${filterId}`;
          
          filterConfig.forEach(item => {
            const subButton = document.createElement('button');
            subButton.id = `filter-sub-${filterId}-${item.id}`;
            subButton.className = 'control-button active filter-sub-button';
            const subLocale = getLocalizedFilterName(currentStyle.metadata.locale, item.id);
            subButton.textContent = subLocale || item.id;
            subButton.onclick = () => toggleSubFilter(filterId, item.id);
            subButtonsContainer.appendChild(subButton);
            
            const subFilterKey = `${filterId}_${item.id}`;
            filterStates[subFilterKey] = true;
          });
          
          groupContainer.appendChild(subButtonsContainer);
        }
        
        filterButtonsContainer.appendChild(groupContainer);
        filterStates[filterId] = true;
      });
    }
  }

  let fpsCounter = 0, lastFpsTime = 0, frameCount = 0;
  let performanceMonitor = null;
  let performancePanelVisible = true;

  function togglePerformancePanel() {
    const panel = document.getElementById('performance-panel');
    performancePanelVisible = !performancePanelVisible;
    panel.style.display = performancePanelVisible ? 'block' : 'none';
  }

  function startPerformanceMonitoring() {
    if (performanceMonitor) return;
    performanceMonitor = setInterval(updatePerformanceMetrics, 1000);
  }

  function stopPerformanceMonitoring() {
    if (performanceMonitor) {
      clearInterval(performanceMonitor);
      performanceMonitor = null;
    }
  }

  function updatePerformanceMetrics() {
    if (!map) return;

    const now = performance.now();
    if (lastFpsTime === 0) {
      lastFpsTime = now;
      frameCount = 0;
    }
    
    frameCount++;
    if (now - lastFpsTime >= 1000) {
      const fps = Math.round((frameCount * 1000) / (now - lastFpsTime));
      document.getElementById('fps-value').textContent = fps;
      document.getElementById('fps-value').className = 
        `metric-value ${fps < 30 ? 'error' : fps < 50 ? 'warning' : 'success'}`;
      
      const frameTime = Math.round(1000 / fps);
      document.getElementById('frame-time-value').textContent = `${frameTime}ms`;
      document.getElementById('frame-time-value').className = 
        `metric-value ${frameTime > 33 ? 'error' : frameTime > 20 ? 'warning' : 'success'}`;
      
      lastFpsTime = now;
      frameCount = 0;
    }

    try {
      const tilesLoaded = map.getStyle()?.sources ? 
        Object.keys(map.getStyle().sources).length : 0;
      document.getElementById('tiles-loaded-value').textContent = tilesLoaded;
      
      const loadingTiles = map.isStyleLoaded() ? 0 : 1;
      document.getElementById('tiles-loading-value').textContent = loadingTiles;
    } catch (e) {
      console.warn('Could not get tile metrics:', e);
    }

    try {
      if (performance.memory) {
        const memoryMB = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
        document.getElementById('memory-usage-value').textContent = `${memoryMB}MB`;
        document.getElementById('memory-usage-value').className = 
          `metric-value ${memoryMB > 500 ? 'error' : memoryMB > 200 ? 'warning' : 'success'}`;
      } else {
        document.getElementById('memory-usage-value').textContent = 'N/A';
      }
    } catch (e) {
      document.getElementById('memory-usage-value').textContent = 'N/A';
    }

    try {
      let activeLayers = 0;
      if (currentStyle?.layers) {
        currentStyle.layers.forEach(layer => {
          if (map.getLayer(layer.id)) {
            const visibility = map.getLayoutProperty(layer.id, 'visibility');
            if (visibility === 'visible') activeLayers++;
          }
        });
      }
      document.getElementById('layers-active-value').textContent = activeLayers;
      document.getElementById('layers-active-value').className = 
        `metric-value ${activeLayers > 50 ? 'warning' : 'success'}`;
    } catch (e) {
      document.getElementById('layers-active-value').textContent = 'N/A';
    }

    try {
      const zoom = map.getZoom();
      document.getElementById('zoom-level-value').textContent = zoom.toFixed(1);
    } catch (e) {
      document.getElementById('zoom-level-value').textContent = 'N/A';
    }
  }

  function countFrame() {
    frameCount++;
    requestAnimationFrame(countFrame);
  }

  initializeMap();
  