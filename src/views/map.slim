ruby:
  proto = env['HTTP_X_FORWARDED_SCHEME'] || env['HTTP_X_FORWARDED_PROTO'] || (request.host =~ /localhost/ ? 'http' : 'https')
  base_url = "#{proto}://" + request.host_with_port + "/styles"
  
  style_name = params[:style]
  style_url = style_name ? "#{base_url}/#{style_name}" : nil

- if style_name
  .layer-controls
    button.layer-button onclick="toggleAllLayers()" Toggle All
    button.layer-button onclick="toggleBasemap()" Toggle Basemap
    #layer-buttons

#map-container
  #map_base.map-layer
  #map.map-layer

javascript:
  const base_url = '#{base_url}';
  const style_url = '#{style_url}';
  let showBasemap = true;
  let layerStates = {};
  let map = null;
  let map_base = null;
  
  map_base = new maplibregl.Map({
    container: 'map_base',
    style: 'https://demotiles.maplibre.org/style.json',
    center: [35.15, 47.41], 
    zoom: 2,
    attributionControl: false,
    interactive: false,
    trackResize: false,
    validateStyle: false
  });
  map_base.triggerRepaint = () => {};
  
  map_base.on('load', () => {
    map_base.setProjection({ type: 'globe' });
  });

  map = new maplibregl.Map({
    container: 'map',
    style: style_url || 'https://demotiles.maplibre.org/style.json',
    center: [35.15, 47.41], 
    zoom: 2,
    attributionControl: false,
    validateStyle: false
  });

  map.addControl(new maplibregl.NavigationControl());
  map.addControl(new maplibregl.GlobeControl(), 'top-right');

  if (style_url) {
    function syncMaps(map, map_base) {
      map.on('move', () => {
        const center = map.getCenter();
        const zoom = map.getZoom();
        const bearing = map.getBearing();
        const pitch = map.getPitch();

        map_base.jumpTo({center, zoom, bearing, pitch});
        map_base.redraw();
        map_base.resize();
      });
    }

    syncMaps(map, map_base);

    map.on('projectiontransition', (e) => {
      map_base.setProjection({ type: e.newProjection });
      map_base.redraw();
      map_base.resize();
    });
  }

  function toggleBasemap() {
    showBasemap = !showBasemap;
    const basemapElement = document.getElementById('map_base');
    basemapElement.style.display = showBasemap ? 'block' : 'none';
  }

  function toggleAllLayers() {
    const allVisible = Object.values(layerStates).every(state => state);
    const newState = !allVisible;
    
    Object.keys(layerStates).forEach(layerId => {
      layerStates[layerId] = newState;
      const visibility = newState ? 'visible' : 'none';
      if (map.getLayer(layerId)) {
        map.setLayoutProperty(layerId, 'visibility', visibility);
      }
    });
    
    updateLayerButtons();
  }

  function toggleLayer(layerId) {
    layerStates[layerId] = !layerStates[layerId];
    const visibility = layerStates[layerId] ? 'visible' : 'none';
    
    if (map.getLayer(layerId)) {
      map.setLayoutProperty(layerId, 'visibility', visibility);
    }
    
    updateLayerButtons();
  }

  function updateLayerButtons() {
    Object.keys(layerStates).forEach(layerId => {
      const button = document.getElementById(`layer-${layerId}`);
      if (button) {
        button.className = `layer-button ${layerStates[layerId] ? 'active' : 'inactive'}`;
      }
    });
  }

  function createLayerButtons() {
    if (!style_url) return;
    
    fetch(style_url)
      .then(response => response.json())
      .then(style => {
        const layerButtonsContainer = document.getElementById('layer-buttons');
        
        if (style.layers) {
          style.layers.forEach(layer => {
            const button = document.createElement('button');
            button.id = `layer-${layer.id}`;
            button.className = 'layer-button active';
            button.textContent = layer.id;
            button.onclick = () => toggleLayer(layer.id);
            
            layerButtonsContainer.appendChild(button);
            layerStates[layer.id] = true;
          });
        }
      })
      .catch(error => {
        console.error('Error loading style:', error);
      });
  }

  map.on('load', async () => {
    map.setProjection({ type: 'globe' });
    
    if (style_url) {
      createLayerButtons();
    }
    
    const popup = new maplibregl.Popup({closeButton: false, closeOnClick: false});

    map.on('click', function (e) {
      const features = this.queryRenderedFeatures(e.point);
      if (features.length > 0) {
        console.log('Clicked feature:', features[0]);
      }
    });

    function popupFeature(features, e) {
      let tt = (tooltip, feat) => tooltip?.replace(/\{([^}]+)\}/g, (match, prop) => {
          let value = feat;
          for (const p of prop.split('.')) { value = value?.[p]; }
          return typeof value === 'object' ? JSON.stringify(value, null, 2) : (value || '');
      });

      let tooltips = features.map((feat) => {
        return tt(feat.layer.metadata?.tooltip, feat) ||
        tt(`<pre>"id": {id},\n"source": {source},\n"source-layer": {sourceLayer},\n"properties": {properties}</pre>`, feat);
      });
      popup.setLngLat(e.lngLat).setHTML(tooltips.join('<br>')).addTo(map);
    }

    let timeout;
    let point;

    map.on('mousemove', (e) => {
      clearTimeout(timeout);

      const features = map.queryRenderedFeatures(e.point);

      if (features.length > 0) {
        map.getCanvas().style.cursor = 'crosshair';
        timeout = setTimeout(() => popupFeature(features, e), 100);
      } else {
        map.getCanvas().style.cursor = '';
        popup.remove();
      }
      if( point && !point.equals(e.point)) { popup.remove(); }
      point = e.point.clone();
    });
  }); 